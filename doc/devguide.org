#+TITLE: Cumulocity SmartREST C++ Library - Developer's Guide
#+DATE: <2016-06-29 Wed>
#+AUTHOR: Xinlei Cao
#+EMAIL: support@cumulocity.com
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline author:t c:nil
#+OPTIONS: creator:comment d:(not "LOGBOOK") date:t e:t email:t f:t inline:t
#+OPTIONS: num:t p:nil pri:nil stat:t tags:t tasks:t tex:t timestamp:t toc:t
#+OPTIONS: todo:t |:t
#+CREATOR: Emacs 24.5.1 (Org mode 8.2.10)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+OPTIONS: texht:t
#+LATEX_CLASS: myreport
#+LATEX_CLASS_OPTIONS: [a4paper,10pt]
# #+LATEX_HEADER: \usepackage[a4paper,head=26pt,foot=11pt,footskip=.25in]{geometry}
#+LATEX_HEADER: \usepackage{mdframed}
# #+LATEX_HEADER: \usepackage{fancyhdr}
# #+LATEX_HEADER: \fancyhf{}
# #+LATEX_HEADER: \lhead{SmartREST C++ Developer's Guide}
# #+LATEX_HEADER: \rhead{\includegraphics[width=.25\textwidth]{img/logo}}
# #+LATEX_HEADER: \rfoot{Page \thepage}
# #+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \hypersetup{
#+LATEX_HEADER:     colorlinks,
#+LATEX_HEADER:     linkcolor={blue!50!black},
#+LATEX_HEADER:     citecolor={red!50!black},
#+LATEX_HEADER:     urlcolor={blue!80!black}
#+LATEX_HEADER: }
#+LATEX_HEADER: \newenvironment{note}
#+LATEX_HEADER: {\begin{mdframed}[backgroundcolor=green!10,font=\footnotesize]}
#+LATEX_HEADER: {\end{mdframed}}
# #+LATEX_HEADER: \renewcommand{\headrulewidth}{2pt}
# #+LATEX_HEADER: \renewcommand{\footrulewidth}{1pt}
#+LATEX_HEADER_EXTRA: \input{title}

#+TOC: listings
#+TOC: tables

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: ch:intro
  :END:

  The SmartREST =c++= library is a =c++= Software Developer Kit (SDK) for facilitating device integration to /Cumulocity/'s Internet of Things (IoT) platform.

  SmartREST is /Cumulocity/'s innovative communication protocol specifically designed for the IoT world. It incorporates the highly expressive strength of the REST API, whereas at the same time replace JSON with Comma Separated Values (CSV) to avoid the complexity of JSON parsing for embedded devices. Additionally, the terseness of CSV renders it highly efficient for IoT communication via mobile networks. It can save update to 80% mobile traffic compared to other HTTP APIs.

  The SmartREST =c++= library is designed for a wide range of devices which are powered by embedded Linux. It implements iterator-style lazy CSV lexer and parser, sophisticated request aggregation and robust request sending, and functionality for /Cumulocity/'s IoT integration, e.g., device registration, real-time device control, SmartREST template registration. The library employs a event-driven design which supports periodical timer callbacks and message based callbacks, which will greatly reduce the development process of integrating your IoT devices to /Cumulocity/'s IoT platform.

* Building the Library
  :PROPERTIES:
  :CUSTOM_ID: ch:build
  :END:
** Prerequisites

#+NAME: tab:prereq
#+CAPTION: Prerequisites for building the library.
|-------------+-----------------+------------------------------------------|
| Software    | Minimal Version | Comment                                  |
|-------------+-----------------+------------------------------------------|
| <l>         | <l>             | <l>                                      |
| Linux       | 2.6.32          |                                          |
| gcc (clang) | 4.7 (3.3)       | both gcc and clang are supported         |
| libcurl     | 7.26.0          | older versions might work, but not tested |
| Lua         | 5.0             | optional, for Lua plugin support only    |
|-------------+-----------------+------------------------------------------|

** Compiling the Library
   First, download a copy of the library from the git repository and change to the directory.

   #+BEGIN_SRC sh :exports code
     $ git clone git@bitbucket.org:m2m/cumulocity-sdk-c.git
     $ cd cumulocity-sdk-c
   #+END_SRC

   Second, create a /init.mk/ file, and define specific macros /CPPFLAGS/, /CXXFLAGS/ and /LDFLAGS/, /LDLIBS/ and /CXX/ if cross-compiling.

   #+CAPTION: example /init.mk/ file
   #+NAME: lst:initmk
   #+BEGIN_SRC makefile
     CXX:=/usr/bin/g++
     CPPFLAGS:=-I/usr/include
     CXXFLAGS:=-Wall -pedantic -Wextra
     LDFLAGS:=-L/usr/lib
     LDLIBS:=-lcurl
   #+END_SRC

   Listing [[lst:initmk]] shows a typical /init.mk/ file example. In essence, /init.mk/ defines search path for required =c++= header files, preferred warning levels, search path for required =c++= library files, and necessary linking flags.

   When you do host compiling, many of these settings can obviously be omitted, these are more relevant for cross-compiling, which shall be the prevalent use case for the library. Later we will explain the /init.mk/ file is also very important for another purpse, i.e., build customization to tailor the library to your needs.

   With the /init.mk/ being defined, it's time to define your /makefile/.

#+BEGIN_SRC sh
$ cp Makefile.template Makefile
#+END_SRC

   The default /Makefile.template/ can be used unchanged in most cases. In case some settings are not suitable for your use case, e.g., you may want =-Os= optimization level instead of the default =-O2=, simply edit the copied /Makefile/.

   Now we have done all preparation work, it's time to build the library for your target device.

#+BEGIN_SRC sh
$ make
#+END_SRC

   If everything is configured correctly, this should compile the library and output the final binary into the /lib// directory, and a watchdog daemon /srwatchdogd/ into the /bin// directory in the root directory.

   The build system supports both /debug/ and /release/ modes. The above command calling make without any target defaults to /debug/ build. /debug/ build produces much larger binary, more verbose output, etc, which is suitable for development phase. When releasing your software, you will likely want a /release/ build, you can clear all intermediate build files and re-build the library in /release/ mode when you want to release your software.

#+BEGIN_SRC sh
$ make clean
$ make release
#+END_SRC

* Using the Library
  :PROPERTIES:
  :CUSTOM_ID: ch:use
  :END:

** Getting Started
   :PROPERTIES:
   :CUSTOM_ID: sec:start
   :END:

   Before we really get started, we will need a /Cumulocity/ account. Go to [[https://cumulocity.com/]], you can apply for a free trial account by click the "TRY CUMULOCITY FREE" button on the top-right corner. After signing-up and login to your tenant, you would find the device registration page in /Device Management/. Next, we will demonstrate how to register a device to /Cumulocity/ using the library.

   #+CAPTION: Cumulocity Registration Page.
   #+NAME: fig:register
   #+ATTR_LATEX: :width 0.8\textwidth
   [[./img/register.png]]

   Without any further ado, let's write our first program, the customary /hello world/ [fn:4] example shown in Listing [[lst:01-hello]].

   #+CAPTION: Hello Cumulocity
   #+NAME: lst:01-hello
   #+BEGIN_SRC C++ :tangle ../examples/ex-01-hello/main.cc :exports code -r
     // ex-01-hello: src/main.cc
     #include <sragent.h>
     #include <srlogger.h>
     using namespace std;

     int main()
     {
             const char *server = "http://developer.cumulocity.com";
             const char *credentialPath = "/tmp/helloc8y";
             const char *deviceID = "13344568";   // unique device identifier
             srLogSetLevel(SRLOG_DEBUG);          // set log level to debug
             SrAgent agent(server, deviceID);     // instantiate SrAgent
             if (agent.bootstrap(credentialPath)) // bootstrap to Cumulocity
                     return 0;
             cerr << "Hello, Cumulocity!" << endl;
             return 0;
     }
   #+END_SRC

   #+BEGIN_NOTE
   It's strongly encouraged that you pick a different random value for ~deviceID~, as it's the unique identifier of your device.
   #+END_NOTE

   For convenience, let's define a shell variable ~C8Y_LIB_PATH~ to hold the library root path and use it to feed the compiler so it can find all necessary =C++= header files and shared library ~.so~ file.

   #+BEGIN_SRC sh
     $ export C8Y_LIB_PATH=/library/root/path
     $ g++ -std=c++11 -I$C8Y_LIB_PATH/include -L$C8Y_LIB_PATH/lib -lsera main.cc
   #+END_SRC

   #+BEGIN_NOTE
   You can define the variable ~C8Y_LIB_PATH~ in your ~.bashrc~ file so you don't need to define it every time when launching a new terminal. From now on, I'd assume you have done so and will mention no more about ~C8Y_LIB_PATH~ in later examples.
   #+END_NOTE

   #+BEGIN_SRC sh
     $ LD_LIBRARY_PATH=$C8Y_LIB_PATH/lib ./a.out
     ...
     Hello, Cumulocity!
   #+END_SRC

   Finally, it's time to run our first program. Type the ~deviceID~ into the text field in your registration page (Fig [[fig:register]]) and click /Register device/. After the program is running, a green /Accept/ button shall show up, click it to accept your device into your tenant.

   As illustrated, the program will print /Hello, Cumulocity!/ then exit. Voila, that's all we need to register a device to /Cumulocity/.

   The obtained device credential is stored in =/tmp/helloc8y= as defined in variable ~credentialPath~. You can also find the credential in the /Device credential/ page in your /Cumulocity/ portal.

   #+BEGIN_NOTE
   If you re-run the program the second time, the program will print /Hello, Cumulocity!/ and exit immediately. This is because the program has loaded available credential from the given credential file. You can manually delete the credential file if you want the program to request a new credential.
   #+END_NOTE

** Integrate to Cumulocity

   Device integration is a little more complex. The whole process is depicted in Fig [[fig:integrate]], please refer to the [[http://cumulocity.com/guides/rest/device-integration/][device integration]] guide for detailed explanation. Steps /1/, /2/ and /3/ are specific to SmartREST protocol as SmartREST requires predefined templates, see [[http://cumulocity.com/guides/rest/smartrest/][SmartREST guide]] and [[http://cumulocity.com/guides/reference/smartrest/][SmartREST reference]] for more information. Step /4/ checks if the device is already stored in /Cumulocity/'s database and only create it when it's not found. Steps /6/ and /7/ get the /Cumulocity/ ID of the device from /Cumulocity/'s database. Step /8/ sets the /Cumulocity/ ID as an alias for the device ID so that the device can find its /Cumulocity/ ID next time by querying with its device ID.

   #+CAPTION: Device integration flowchart.
   #+NAME: fig:integrate
   #+ATTR_LATEX: :width 0.25\textwidth
   [[./img/integrate.png]]

   #+CAPTION: Integrate to Cumulocity: API inteface
   #+NAME: lst:02-header
   #+BEGIN_SRC C++ :tangle ../examples/ex-02-integrate/integrate.h :exports code :main no -r
     // ex-02-integrate: src/integrate.h
     #ifndef INTEGRATE_H
     #define INTEGRATE_H
     #include <sragent.h>

     class Integrate: public SrIntegrate
     {
     public:
             Integrate(): SrIntegrate() {}
             virtual ~Integrate() {}
             virtual int integrate(const SrAgent &agent, const string &srv,
                                   const string &srt);
     };

     #endif /* INTEGRATE_H */
   #+END_SRC

   Listing [[lst:02-header]] shows the required API interface[fn:1] by ~SrAgent~ when implementing your own integrate process. Basically, you need to subclass the pure virtual class ~SrIntegrate~ and realize its virtual function ~integrate~ with your particular integrate process. This is a callback function, which will be called by ~SrAgent~ when you call the ~integrate~ method of the ~SrAgent~. By convention, the function shall returned 0 for success, and a non-0 value for failure.

   #+CAPTION: Integrate to Cumulocity: implementation
   #+NAME: lst:02-integrate
   #+BEGIN_SRC C++ :tangle ../examples/ex-02-integrate/integrate.cc :exports code :main no -r
     // ex-02-integrate: src/integrate.cc
     #include <srnethttp.h>
     #include <srutils.h>
     #include "integrate.h"
     using namespace std;


     int Integrate::integrate(const SrAgent &agent, const string &srv,
                              const string &srt)
     {
             SrNetHttp http(agent.server()+"/s", srv, agent.auth());
             if (registerSrTemplate(http, xid, srt) != 0) // Step 1,2,3
                     return -1;

             http.clear();
             if (http.post("100," + agent.deviceID()) <= 0) // Step 4
                     return -1;
             SmartRest sr(http.response());
             SrRecord r = sr.next();
             if (r.size() && r[0].second == "50") { // Step 4: NO
                     http.clear();
                     if (http.post("101") <= 0) // Step 5
                             return -1;
                     sr.reset(http.response());
                     r = sr.next();
                     if (r.size() == 3 && r[0].second == "501") {
                             id = r[2].second; // Step 7
                             string s = "102," + id + "," + agent.deviceID();
                             if (http.post(s) <= 0) // Step 8
                                     return -1;
                             return 0;
                     }
             } else if (r.size() == 3 && r[0].second == "500") { // Step 4: YES
                     id = r[2].second;                           // Step 6
                     return 0;
             }
             return -1;
     }
   #+END_SRC

   Listing [[lst:02-integrate]] realizes the flow chart depicted in Fig [[fig:integrate]]. You may have noticed all requests are Comma Separated Values (CSV) since we are using SmartREST instead of REST APIs directly. The corresponding SmartREST templates can be found in Listing [[lst:02-main]]. Important thing to note is that, you must store the correct SmartREST /X-ID/ and device's /Cumulocity ID/ in the inherited member variables ~xid~ and ~id~, respectively. They will be used by ~SrAgent~ after the integrate process for initializing corresponding internal variables.

   #+CAPTION: Created device in /Cumulocity/ after integrate process.
   #+ATTR_LATEX: :width 0.8\textwidth
   #+NAME: fig:mo
   [[./img/mo.png]]

   Listing [[lst:02-main]] extends the code in Listing [[lst:01-hello]]. The only addition inside the ~main~ function is the call to ~SrAgent~'s member function ~integrate~ for integrating to /Cumulocity/ and ~loop~ for executing the agent loop[fn:2]. Above the ~main~ function is the definition of the SmartREST template version number and actual template content[fn:3].

   Please refer to Section [[#sec:start]] about how to compile and run the code. After running this example code, you should see a device named =HelloC8Y-Agent= in /All devices/ page in your /Cumulocity/ tenant, as shown in Fig [[fig:mo]].

   #+CAPTION: Integrate to Cumulocity: main function
   #+NAME: lst:02-main
   #+BEGIN_SRC C++ :tangle ../examples/ex-02-integrate/main.cc :exports code -r
     // ex-02-integrate: src/main.cc
     #include <sragent.h>
     #include <srlogger.h>
     #include "integrate.h"
     using namespace std;

     static const char *srversion = "helloc8y_1"; // SmartREST template version
     static const char *srtemplate =              // SmartREST template collection
             "10,100,GET,/identity/externalIds/c8y_Serial/%%,,"
             "application/json,%%,STRING,\n"

             "10,101,POST,/inventory/managedObjects,application/json,"
             "application/json,%%,,\"{\"\"name\"\":\"\"HelloC8Y-Agent\"\","
             "\"\"type\"\":\"\"c8y_hello\"\",\"\"c8y_IsDevice\"\":{},"
             "\"\"com_cumulocity_model_Agent\"\":{}}\"\n"

             "10,102,POST,/identity/globalIds/%%/externalIds,application/json,,%%,"
             "STRING STRING,\"{\"\"externalId\"\":\"\"%%\"\","
             "\"\"type\"\":\"\"c8y_Serial\"\"}\"\n"

             "11,500,$.managedObject,,$.id\n"
             "11,501,,$.c8y_IsDevice,$.id\n";

     int main()
     {
             const char *server = "http://developer.cumulocity.com";
             const char *credentialPath = "/tmp/helloc8y";
             const char *deviceID = "13344568"; // unique device identifier
             srLogSetLevel(SRLOG_DEBUG);        // set log level to debug
             Integrate igt;
             SrAgent agent(server, deviceID, &igt); // instantiate SrAgent
             if (agent.bootstrap(credentialPath))   // bootstrap to Cumulocity
                     return 0;
             if (agent.integrate(srversion, srtemplate)) // integrate to Cumulocity
                     return 0;
             agent.loop();
             return 0;
     }
   #+END_SRC

** Send Measurement

   Now we have successfully integrated a demo device to /Cumulocity/, we can finally do something more interesting. Let's try sending CPU measurement every 10 seconds.

   As shown in Listing [[lst:03-main]][fn:5], we need to first add a new SmartREST template for CPU measurement, and also increase the SmartREST template version number. Then we subclass the pure virtual class ~SrTimerHandler~ and implement the ~()~ operator. ~CPUMEasurement~ is a functor callback, which generates bogus CPU measurements using the ~rand~ function from the standard library. It will be called by the ~SrAgent~ at defined interval of the registered ~SrTimer~ .

   In the ~main~ function, we instantiate a ~CPUMEasurement~ and register it to an ~SrTimer~ in the /constructor/. ~SrTimer~ supports millisecond resolution, so 10 seconds is 10 * 1000 milliseconds.

   The library is built upon an asynchronous model. Hence, the ~SrAgent~ class is not responsible for any networking duty, it is essentially a scheduler for all timer and message handlers. ~SrAgent.send~ merely places a message into the ~SrAgent.egress~ queue, and returns immediately after. For actually sending SmartREST requests to /Cumulocity/, we need to instantiate a ~SrReporter~ object and execute it in a separate thread.

   #+CAPTION: Send pesudo CPU measurement to Cumulocity.
   #+NAME: lst:03-main
   #+BEGIN_SRC C++ :tangle ../examples/ex-03-measurement/main.cc :exports code -r
     // ex-03-measurement: src/main.cc
     #include <cstdlib>

     static const char *srversion = "helloc8y_2";
     static const char *srtemplate =
     // ...
             "10,103,POST,/measurement/measurements,application/json,,%%,"
             "NOW UNSIGNED NUMBER,\"{\"\"time\"\":\"\"%%\"\","
             "\"\"source\"\":{\"\"id\"\":\"\"%%\"\"},"
             "\"\"type\"\":\"\"c8y_CPUMeasurement\"\","
             "\"\"c8y_CPUMeasurement\"\":{\"\"Workload\"\":"
             "{\"\"value\"\":%%,\"\"unit\"\":\"\"%\"\"}}}\"\n"
     // ...

     class CPUMeasurement: public SrTimerHandler {
     public:
             CPUMeasurement() {}
             virtual ~CPUMeasurement() {}
             virtual void operator()(SrTimer &timer, SrAgent &agent) {
                     const int cpu = rand() % 100;
                     agent.send("103," + agent.ID() + "," + to_string(cpu));
             }
     };

     int main()
     {
             // ...
             CPUMeasurement cpu;
             SrTimer timer(10 * 1000, &cpu); // Instantiate a SrTimer
             agent.addTimer(timer);          // Add the timer to agent scheduler
             timer.start();                  // Activate the timer
             SrReporter reporter(server, agent.XID(), agent.auth(),
                                 agent.egress, agent.ingress);
             if (reporter.start() != 0)      // Start the reporter thread
                     return 0;
             agent.loop();
             return 0;
     }

   #+END_SRC

   #+BEGIN_NOTE
   If you add a ~SrTimer~ to the ~SrAgent~, you must ensure its existence throughout the program lifetime[fn:7], since there is no way to remove a ~SrTimer~ from the ~SrAgent~. Instead, you can use ~SrTimer.connect~ to register a different callback or deactivate it by ~SrTimer.stop~. This is a design choice for encouraging timer reuse, instead of dynamically creating and destroying timers.
   #+END_NOTE

** Handle Operation

   Besides sending requests, e.g., measurements to /Cumulocity/, the other important functionality is handle messages, either responses from /GET/ queries or real-time operations from /Cumulocity/. Listing [[lst:04-main]] demonstrates how to handle the /c8y_Restart/ operation. Again, first we will need to register necessary SmartREST templates. Then we define a message handler for handling restart operation.

   In the ~main~ function, we register the ~RestartHandler~ for SmartREST template $502$, which is the template for the restart operation. We also need to instantiate a ~SrDevicePush~ object and starting execute device push in another thread. From now on, as soon as you execute an operation from your /Cumulocity/ portal, device push will receive the operation immediately and your message handler will be invoked by the ~SrAgent~.

   #+CAPTION: Handle relay operation
   #+NAME: lst:04-main
   #+BEGIN_SRC C++ :tangle ../examples/ex-04-operation/main.cc :exports code -r
     // ex-04-operation: src/main.cc
     static const char *srversion = "helloc8y_3";
     static const char *srtemplate =
     // ...
             "10,104,PUT,/inventory/managedObjects/%%,application/json,,%%,"
             "UNSIGNED STRING,\"{\"\"c8y_SupportedOperations\"\":[%%]}\"\n"

             "10,105,PUT,/devicecontrol/operations/%%,application/json,,%%,"
             "UNSIGNED STRING,\"{\"\"status\"\":\"\"%%\"\"}\"\n"
     // ...
             "11,502,,$.c8y_Restart,$.id,$.deviceId\n";
     // ...

     class RestartHandler: public SrMsgHandler {
     public:
             RestartHandler() {}
             virtual ~RestartHandler() {}
             virtual void operator()(SrRecord &r, SrAgent &agent) {
                     agent.send("105," + r.value(2) + ",EXECUTING");
                     for (int i = 0; i < r.size(); ++i)
                             cerr << r.value(i) << " ";
                     cerr << endl;
                     agent.send("105," + r.value(2) + ",SUCCESSFUL");
             }
     };

     int main()
     {
             // ...
             // Inform Cumulocity about supported operations
             agent.send("104," + agent.ID() + ",\"\"\"c8y_Restart\"\"\"");
             RestartHandler restartHandler;
             agent.addMsgHandler(502, &restartHandler);
             SrDevicePush push(server, agent.XID(), agent.auth(),
                               agent.ID(), agent.ingress);
             if (push.start() != 0)      // Start the device push thread
                     return 0;
             agent.loop();
             return 0;
     }
   #+END_SRC

   Now run the program, then go to your /Cumulocity/ tenant, execute an restart operation as shown in Fig [[fig:restart]]. You should see the message printed in ~cerr~ and the operation is set to /SUCCESSFUL/ in your control tab in /Cumulocity/.

   #+NAME: fig:restart
   #+CAPTION: Execute a restart operation in /Cumulocity/.
   #+ATTR_LATEX: :width .7\textwidth
   [[./img/restart.png]]

** Store SmartREST Templates in a File

   Over time, your template collection would grow large, and you would like to store them in a text file instead of hard coding them in your source code. The benefits are tow-fold: you don't need to recompile the code every time only because the templates change, and there is no need to escape special characters which is error-prone.

   A utility function ~readSrTemplate~ is provided for reading template collection from a text file. Listing [[lst:05-main]] shows the usage of this function. It reads file /srtemplate.txt/ from the current directory and stores the version number and template content into arguments ~srversion~ and ~srtemplate~, respectively.

   The file format required by ~readSrTemplate~ is as simple as following:

   #+ATTR_LATEX: :options [noitemsep]
   - First line contains only the template version number.
   - Every template must be on one line of its own.
   - A line starts with =#= as first character (with no leading spaces or tabs) is considered a comment line and will be ignored.
   - A complete empty line (with no spaces and tabs) will be ignored.
   - No trailing spaces or tabs are allowed for any line except comment lines.

   #+CAPTION: SmartREST template collection stored in a text file.
   #+NAME: lst:05-srtemplate
   #+BEGIN_SRC sh :exports code -r
     helloc8y_3
     10,100,GET,/identity/externalIds/c8y_Serial/%%,,application/json,%%,STRING,
     10,101,POST,/inventory/managedObjects,application/json,application/json,%%,, "{""name"":""HelloC8Y-Agent"",""type"":""c8y_hello"", ""c8y_IsDevice"":{},""com_cumulocity_model_Agent"":{}}"

     10,102,POST,/identity/globalIds/%%/externalIds,application/json,,%%,STRING STRING,"{""externalId"":""%%"",""type"":""c8y_Serial""}"

     10,103,POST,/measurement/measurements,application/json,,%%,NOW UNSIGNED NUMBER,"{""time"":""%%"",""source"":{""id"":""%%""}, ""type"":""c8y_CPUMeasurement"", ""c8y_CPUMeasurement"":{""Workload"":{""value"":%%,""unit"":""%""}}}"

     10,104,PUT,/inventory/managedObjects/%%,application/json,,%%,UNSIGNED STRING, "{""c8y_SupportedOperations"":[%%]}"
     10,105,PUT,/devicecontrol/operations/%%,application/json,,%%,UNSIGNED STRING, "{""status"":""%%""}"

     11,500,$.managedObject,,$.id
     11,501,,$.c8y_IsDevice,$.id
     11,502,,$.c8y_Restart,$.id,$.deviceId
   #+END_SRC

   #+CAPTION: Read SmartREST template from a text file.
   #+NAME: lst:05-main
   #+BEGIN_SRC C++ :exports code -r
     // ex-05-template: src/main.cc
     #include <srutils.h>
     // ...

     int main()
     {
             // ...
             string srversion, srtemplate;
             if (readSrTemplate("srtemplate.txt", srverision, srtemplate) != 0)
                     return 0;
             // ...
     }

   #+END_SRC

** Lua Plugin

   Instead of using =c++= for your development, the library also supports rapid development in =Lua=. For =Lua= plugin support, you must build the library with explicitly enabling =Lua= support, as it's disabled by default, see Chapter [[#ch:custom]] about how to enable =Lua= plugin support.

   Listing [[lst:06-main]] demonstrates how to load a =Lua= plugin and add path ~lua/~ into =Lua='s ~package.path~ for library search path.

   #+CAPTION: Load =Lua= plugin.
   #+NAME: lst:06-main
   #+BEGIN_SRC C++ :exports code -r
     // ex-06-lua: src/main.cc
     #include <srluapluginmanager.h>
     // ...

     int main()
     {
             // ...
             SrLuaPluginManager lua(agent);
             lua.addLibPath("lua/?.lua");  // add given path to Lua package.path
             lua.load("lua/myplugin.lua"); // load Lua plugin
             // ...
             return 0;
     }
   #+END_SRC

   Listing [[lst:06-lua]] shows how to send CPU measurements and handle operation in =Lua= instead of =c++=. All =Lua= plugins are managed by ~SrLuaPluginManager~, it is exposed to all =Lua= plugins as an opaque object named /c8y/. The only requirement for a =Lua= plugin is having a ~init~ function, which will be called by ~SrLuaPluginManager~ at load time to initialize the =Lua= plugin[fn:6].

   The example also shows how to define your own =Lua= library and share its variable ~myString~ in your =Lua= plugins.

   #+CAPTION: Send measurement and handle operation using =Lua=.
   #+ATTR_LATEX: :float t
   #+NAME: lst:06-lua
   #+BEGIN_SRC lua :tangle ../examples/ex-06-lua/lua/myplugin.lua
     -- ex-06-lua: lua/mylib.lua
     myString = "Hello, Cumulocity!"

     ----------------------------------------

     -- ex-06-lua: lua/myplugin.lua
     require('mylib')
     local timer

     function restart(r)
        c8y:send('105,' .. r:value(2) .. ',EXECUTING')
        for i = 0, r.size - 1 do     -- index in C++ starts from 0.
           srDebug(r:value(i))
        end
        c8y:send('105,' .. r:value(2) .. ',SUCCESSFUL')
     end

     function cpuMeasurement()
        local cpu = math.random(100)
        c8y:send('103,' .. c8y.ID .. ',' .. cpu)
     end

     function init()
        srDebug(myString)            -- myString from mylib
        timer = c8y:addTimer(10 * 1000, 'cpuMeasurement')
        c8y:addMsgHandler(502, 'restart')
        return 0                     -- signify successful initialization
     end
   #+END_SRC

* Build Customization
  :PROPERTIES:
  :CUSTOM_ID: ch:custom
  :END:

  In Chapter [[#ch:build]] we briefly explained how to build the library, in this chapter we will go into depth about how to customize the build options to tailor a optimal build for your particular use case.

  All customization options listed in the following shall be added in your /init.mk/ file.

**** ~SR_PLUGIN_LUA=0~

     Switch for =Lua= plugin support, defaults to 0, which disables =Lua= support. Set it to 1 will enable =Lua= plugin support. Also remember to provide necessary =Lua='s =C= library and add to your ~CPPFLAGS~, ~CXXFLAGS~, ~LDFLAGS~ and ~LDLIBS~ the required compile and link flags, etc.

**** ~SR_PROTO_HTTP_VERSION=1.1~

     HTTP version, defaults to 1.1. Set it to 1.0 for environments when =HTTP/1.1= is not supported.

**** ~SR_SOCK_RXBUF_SIZE=1024~

     Maximum receive buffer size for ~SrNetSocket~, defaults to 1024 bytes. This number dictates the maximum number of bytes the ~recv~ method of ~SrNetSocket~ can block waiting for response. This parameter only affects the receive buffer of ~SrNetSocket~.

**** ~SR_AGENT_VAL=5~

     Polling interval for ~SrAgent~, defaults to 5 milliseconds. Internally ~SrAgent~ schedules all ~SrTimerHandler~ and ~SrMsgHandler~ by constantly polling for expired ~SrTimer~ and arrived messages from ingress ~SrQueue~, this parameter dictates the interval between two consecutive polling. When is parameter is set too high, the agent may appear to be sluggish, whereas when set too low, many CPU cycles are wasted. This is a trade-off parameter that needs to be fine-tuned for any particular device.

**** ~SR_REPORTER_NUM=32~

     Maximum number of aggregated requests, defaults to 32. For saving traffic use, ~SrReporter~ has a mechanism to aggregate many messages into one request and send them all in once. This number dictates the maximum number of messages that can be aggregated.

**** ~SR_REPORTER_VAL=400~

     Maximum waiting time between two consecutive requests for aggregation, defaults to 400 milliseconds. When aggregating requests, ~SrReporter~ will wait for consecutive messages with a defined timeout. If the next messages comes after the timeout, ~SrReporter~ will stop the waiting loop and starts sending the already aggregated messages. When set to a higher number, higher aggregation can be expected, therefore, results in lower traffic use, whereas when set to a lower number, agent will be more responsive since it will not wait for aggregating next message. This is a trade-off parameter that needs to be fine-tuned for any particular use case.

**** ~SR_REPORTER_RETRIES=10~

     Maximum number of retries when sending fails, defaults to 10 times. For counteracting temporary network failures, ~SrReporter~ implemented an exponential wait and multi-trials measure. When the first trial fails, it waits 1 second and retries again, when the second trial fails, it waits 2 seconds, when the third trial fails, it waits 4 seconds, and so on, until the defined number of retries exhausted. Note when ~SrReporter~ enters the retry loop, messages sent via ~SrAgent~ will be queued up in the egress ~SrQueue~, until the ~SrReporter~ successfully sends the aggregated requests so far or exhausts all retries.

**** ~SR_CURL_SIGNAL=1~

     Whether allow /libcurl/ from installing any signal handlers, defaults to 1, which allows /libcurl/ to install signal handlers. Certain versions of /libcurl/ contains a bug that when built with a synchronous DNS resolver, randomly crashes when the DNS lookup timed out. When you experience this issue, you can workaround this bug by disabling /libcurl/ from installing signal handlers. As a side effect, /libcurl/ will not be able to terminate DNS lookup, recommended approach is to re-built /libcurl/ with an asynchronous DNS resolver.

**** ~SR_SSL_VERIFYCERT=1~

     Whether to verify server's certificate when using HTTPS, defaults to 1. Many embedded devices have no CA certificates installed and thus not be able to verify server's certificate when communicating via HTTPS. As a workaround, you can disable certificate verification by setting this macro to 0.

* Footnotes

[fn:1] The API reference is located in relative path ~doc/html/index.html~ in the library repository.

[fn:2] The agent loop is an infinite loop, so it will never really returns. We will get back to this function later.

[fn:3] Consult the [[http://cumulocity.com/guides/reference/smartrest/][SmartREST reference]] about how to define SmartREST templates.

[fn:4] All examples can be found in the ~examples~ folder in the repository.

[fn:5] The code excerpt only includes the added part, check the /examples/ folder for the complete example code.

[fn:6] Check =Lua= API reference in ~doc/lua.html~ for a complete list of all available APIs.

[fn:7] This is especially important when you dynamically allocate a timer on the heap, you must not destroy it during the program is running.
